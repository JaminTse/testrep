# 区块链技术基础

## 区块链定义

**区块链就是通过密码学的方式形成的一个由集体维护的分布式数据库。** 

区块链技术是利用块**链式数据结构**来验证与存储数据、利用分布式节点**共识算法**来生成和更新数据

## 区块链基本原理

小明和小红每人有一个比特币的地址（公钥：相当于是我们银行卡的卡号 ）和一个私钥（相当于银行卡密码或者说你的签名），像这个样子：

```text
1JQMpgRThCJjKbs7P8Ht6x142zjPJFmZVY
```

我们需要填写转账的金额和对方的比特币地址，就像我们平时用银行卡转账一样的操作，一段时间后，对方即可收到你的转账金额。

这是作为用户能感知到的，看上去和我们平时的转账交易没什么不同，只是“卡号”看起来奇怪了一点，交易时间变长了一点。

那么当你按下“转账”按钮时，背后的区块链系统到底发生了什么？

1. 使用私钥对这笔即将发生的交易进行签名
2. 从你的客户端把你的这笔交易提交到区块链网络
3. 由已经开启“挖矿”程序的计算机（称为矿机）把10分钟内的交易打包成一个数据块（相当于一个账本，其中就包含了小明的这笔交易）
4. 这个数据块就是上图中的“区块主体”，而此时，这些区块主体中的交易并未生效。
5. 那么如何使这些交易生效呢？每个区块中都有一个哈希值，通过不断哈希运算，不断哈希运算（可能是几亿次）最终找到一个比当前哈希小的值，就认为这个区块被确认。即为交易生效，这个过程就称为“挖矿”。
6. 那谁来做这个哈希呢？全球那么多交易，如果只是一家公司的几台计算机是远远不够的。所以，比特币有“激励机制”，当一台计算机确认了一个区块，就可以奖励12.5个比特币。为了得到Money，越来越多矿工就有动力造更大更多算力的矿机来“挖矿 ”。越多的人参与挖矿的竞争，算力就越分散，比特币系统就越不可能被某一个人控制。这就形成了“双赢”的局面。

### 电子签名（公钥 - 私钥对）

电子签名被发明的核心目的是确认写这个签名的人是本人，即身份确认（验证）

私钥，顾名思义也叫密钥，是你本人需要妥善保管和保存的

```
Sign(信息,私钥)=电子签名
```

Sign在这里是一个函数（可理解为一连串计算），其特点是**输入值只要改变一点点**，输出就会**完全改变**。

```
Verify(信息，电子签名，公钥) = 真 / 假
```

解释完电子签名，我们来看看实例。`小明`使用自己的私钥加上`小明转给小红10块钱`**这段话**通过Sign函数生成一个签名（256位），把签名放在这条转账信息的后面，通过之前的讲解，这个签名就能保证`小明`已经过目了，并且说：“这真的是我`小明`，不用怀疑了！肯定是我”

直观结果是，我们可以利用**密码学的手段**，只要有对应人的**数字签名**，我们保证`小明`和`小红`的**身份能被100%确认真实**

但是这个解决方案有一个小漏洞：可以**复制同一行信息**来伪造交易记录，解决的办法是添加一个**这笔交易独有的信息（比如时间戳）**



### 密码学：哈希（摘要算法）
哈希函数，输入可以是任意信息或者文件，输出是固定长度的比特串。例如256bit的1/0串，这个输出叫做这个信息的“哈希值”或者“摘要”（digest）。
**SHA256就是一个哈希函数**

哈希函数的特点：
- 特点是输入值稍微变化后，结果就会有很大的不同，完全无法预测不同输入间的规律
- 逆向计算不可行，只能使用试错法（穷举法），解空间2的256次方

### 区块

#### 区块数据结构
区块的结构，区块头和内部交易数据组成。区块头包含：区块编号、上一区块哈希值、本区块哈希值、挖矿随机数、难度、时间戳
 <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1640332394342.png" alt="1640332394342" style="zoom:150%;" />

- 区块高度：可以理解为每个区块的唯一ID，从零开始的“创世块”，每生成一块区块，块高度加一
- 头哈希：每一个区块都有唯一的哈希值， 依据上一个区块的头哈希+数据块哈希+随机数生成 
- 父哈希：上一个区块的哈希值
- merkle根：区块中每一笔交易对应一个哈希，呈树状结构，生成最终值（根），代表该区块中的交易
> Merkle树：
> 每个区块中的所有交易，都是用Merkle树来表示的。换句话说，交易的存储**数据结构**是，Merkle树
> Merkle树是一种哈希二叉树，它可以用来进行快速查找和检验大规模数据完整性。对于比特币网络来说，使用Merkle树来存储交易信息的目的是为了**高效的查找和校验某笔交易的信息是否存在**
> 当N个数据元素经过加密（使用两次SHA256算法，也称double-SHA256），至多计算 2log2（n）次就能检查出任意某元素是否在树中
> 构造Merkle树：
> 假设我们有A B C D四笔交易字段，首先需要把这四个数据Hash化。然后把这些哈希化的数据通过串联相邻叶子节点的哈希值然后哈希化。
 ![1640224947318](https://charlesliuyx.github.io/2017/09/24/%E4%B8%80%E6%96%87%E5%BC%84%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE-%E4%BB%A5%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%BA%E4%BE%8B/MerkleTree.png)
> 叶子节点必须是偶数（平衡树），如果遇到奇数的情况，把最后一个节点自身复制一个，凑偶

- 难度系数：难度不是固定不变的，会随着网络现有算力的变化而自动调节
对于每一种不同的加密货币来说，都有一个值需要在建立货币的时候时候被定义，即每一个新区块在当前全网算力的条件被发现的【平均时间】，这也是难度系数的由来
> 比特币10分钟；以太坊15秒；瑞波币3.5秒；莱特币2.5分钟
实现方法就是通过找前n位是0的方法。从概率角度来说，n值越大，意味找到这个这个数的解范围越小。
随着需求0的数目一个一个增加，需要的计算时间将会程指数增长。
> 难度调整方式：
> 难度的调整是在每个完整节点中**自动**发生的。如果网络发现区块产生速率比10分钟要快时会增加难度。如果发现比10分钟慢时则降低难度。
> <font color='blue'>问题又来了，为何我不自己降低难度，让自己更加容易新建区块呢？其实，因为链上所有节点确认新的区块（只有确认了你才能得到回报）是按照最长链并且计算难度最大来判断的，你如果用很小的难度新加的区块，是肯定跑不赢全网的其他矿工的</font>

- Nonce：挖矿所要达到的**目标值**
- 区块体：一定时间内所生成的交易信息，即账本

1. 把在本地内存中的交易信息记录到区块主体中
2. 在区块主体中生成**此区块中所有交易信息**的 Merkle 树，把 Merkle 树根的值保存在**区块头**中
3. 把**上一个**刚刚生成的区块的**区块头**的数据通过 SHA256 算法生成一个哈希值填入到当前区块的父哈希值中
4. 把当前时间保存在时间戳字段中
5. 难度值字段会根据之前一段时间区块的平均生成时间进行调整以应对整个网络不断变化的整体计算总量，如果计算总量增长了，则系统会调高数学题的难度值，使得预期完成下一个区块的时间依然在一定时间内

### 链

### 分布式

### 工作量证明 PoW

Proof of Work，即获得多少货币，取决于挖矿贡献的有效工作，根据你的工作证明来执行货币的分配（算力越高、挖矿时间越长、获得的货币就越多），简单理解就是“多劳多得” 

为了获得账本记录权，必须率先完成计算密集型的任务，受制于其算力。

> 完成的任务是什么呢？
> 找出一个随机数，使得最终的SAH256哈希值输出的开头有一连串的0（符合规则的个数），而由于哈希函数的输出不可预测，找到这个特定的随机数的唯一方法就是穷举，即**通过海量的计算寻找这个随机数**（工作量证明）
> 所以，如果修改了一个交易，哪怕只是一个字符，就会完全改变哈希值，就得重做工作量证明。

**要点**：节点反复尝试寻找一个数值，使得将该数值、区块链中**最后一个区块的Hash值以及交易单**三部分送入SHA256算法后能计算出散列值X（256位）满足一定条件（比如前20位均为0），即找到数学难题的解。由此可见，答案并不唯一

**优点**：其算法采用了目前行业内大家普遍认可的寻找随机数，比较简单且容易实现。同时就是安全性非常的高，因为犯错的成本很高，所以也就导致了比特币安全运行十年依然没有出现任何大的系统隐患。

**缺点**：因为矿机设备需要耗费了大量的电力和水力，处理效率比较低。现在有**矿池**的出现，算力集中在个别几家，那也就可能他们的算力超过全网的51%，就有做坏事的条件了，比如<font color='blue'>强行分叉一条新的链</font>。随着大矿池的出现，也就越来越中心化。违背了区块链的初衷。(BTC.COM，Antpool，ViaBTC前三大矿池，已经占到了全网52.4%的算力水平。)

>  “矿池”就是有一个大的基地，里面放置了大量矿机在挖矿，挖到的矿再经过体系内进行分配，一般是谁出的资源多，谁占多点。 
> 挖矿：
> 接受交易信息，建造区块，把区块广播出去，然后得到新的钱作为奖励
### 权益证明 PoS

Proof of Stake，即系统中存在一个持币人的集合，他们将一定的代币放到PoS机制中，<font color='blue'>于是他们变成了验证者</font>（ ==参与者的角色是验证者Validator，只需要投资系统的数字货币并在特定时间内验证自己是否为下一区块创造者==），拥有了验证交易和产生区块的权利。PoS算法会在这个集合中随机选择一个节点赋予记录权，一定时间内该节点没有产生一个区块，则选出第二个节点。在这个过程中，被选中的概率与投入的代币量有关。

> 在PoW中，拥有算力越多，被选为提议下个区块（即获得账本记录权）的概率就越高。
>
> 在PoS中，拥有的代币越多，成为区块生产者的概率就越高。

### 授权权益证明 DPoS

Delegated Proof of Stake，又称受托人机制，原理是让每个持有比特股的人进行投票，由此产生101（或21，取决于设计）位代表（超级节点或者矿池）。简单来说，DPoS就是将PoS中的记账者转换为**指定节点数组成的小圈子**，而不是所有人都可以参与记账， 这将极大地提高系统的吞吐量，因为更少的节点也就意味着网络和节点的可控。 

<font color='blue'> PoS和PoW到底是不是共识算法呢</font>

![1640224947318](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1640224947318.png)

 还没有开始谈论如何就区块达成共识。有一种常见的误解，认为PoW和PoS是共识算法。其实它们不是。它们只是通过约束稀缺资源的方式来选择区块生产者。 

### 拜占庭容错

#### 拜占庭将军问题

 <img src="https://charlesliuyx.github.io/2018/03/03/%E3%80%90%E5%8C%BA%E5%9D%97%E9%93%BE%E3%80%91%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98/BG1.png" alt="img" style="zoom:33%;" /> 

9个将军带领9支军队，打一场攻城战役。假设每个将军都能独立根据眼前战况做出两种判断：**进攻**或**撤退**，要求（或者最终目的是）如何让这9个将军的命令是**一致的**（一致性，即共识）？要么一起进攻，要么一起撤退（每个将军之间也是互不信任的，也有消灭对方的动机）

最简单的策略即：**投票**（上图中的红色箭头和绿色箭头为每个将军做出的判断），**超过半数支持**某个决定，那么所有9个将军一定执行这个决定。如上图，5个将军决定进攻，4个将军决定撤退，那么所有将军都会下令：进攻！

这种策略需要每个将军把自己的判断通过一种途径（途中灰色箭头）传递到所有其他将军处。相对的，每个将军只有在收到了所有投票结果后，才会下令。如上面的例子，所有将军得到投票：**4进攻5撤退**，才下令**撤退**

 <img src="https://charlesliuyx.github.io/2018/03/03/%E3%80%90%E5%8C%BA%E5%9D%97%E9%93%BE%E3%80%91%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98/BGP.png" alt="img" style="zoom:33%;" /> 

这个**投票策略**的最大问题：假设出现了**叛徒**，如上图所示，会出现两种情况

- 【1】对自己位置的战场情况进行错误广播（比如他这个地方优势很大，但是投票给撤退）
- 【2】可以选择靠给不同的将军送去不同的消息**破坏整体决定的一致性**（导致左边四个将军选择撤退，右边四个将军选择进攻）

根据相关的研究，得出一个【一般性的结论】：**如果叛徒的数量大于或等于三分之一 ，那么拜占庭问题不可解**，这个三分之一也被称为**拜占庭容错**

推广到计算机系统内，【将军】类比为【计算机】，而计算机因为物理或被感染等其他原因造成的【运行异常】就是【叛徒】，其实整个问题也是为了保证分布式系统的**一致性**和**可用性**

#### 传统解决方案

**口头协议**（又称为拜占庭容错算法）和**书面协议** 

通常来说，大多数分布式系统使用的是书面协议确保一致性，中心机构背书。其中有实用拜占庭容错算法（PBFT）最为有名 

#### 书面协议中的PBFT

核心思想是：**对于每一个收到命令的将军，都要去询问其他人，他们收到的命令是什么**。也就是说利用不断的信息交换**让可行的节点确认哪一个记录选择是正确的，即发现其中的背叛者** 

采用PBFT方法，本质上就是**利用通信次数换取信用**。每个命令的执行都需要节点间两两交互去核验消息，通信代价是非常高的。通常采用PBFT算法，节点间的通信复杂度是节点数的平方级的 

 ![img](https://charlesliuyx.github.io/2018/03/03/%E3%80%90%E5%8C%BA%E5%9D%97%E9%93%BE%E3%80%91%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98/PBFT.png) 

#### 区块链中的PBFT

 <img src="https://charlesliuyx.github.io/2018/03/03/%E3%80%90%E5%8C%BA%E5%9D%97%E9%93%BE%E3%80%91%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98/BlockChain.png" alt="img" style="zoom:50%;" /> 

每个将军本地都存储一份【记录】：记录所有将军的决定，比如“1：1”代表1号将军决定进攻

然后构造以下协议内容：

- 使用数字签名保证身份可可信
- 所有将军**参与挖矿**，国王以保证战役胜利为缘由，出资，奖励每一个挖到新区块俩的将军
- 每一个将军当本地维护的**最新确认【记录】**中包含了所有1-9号将军的决定后，**正式做出自己的决定**

在这个案例中，抛弃了代币的设定，因为不存在交易行为，而是由国王出资（保证战争不被间谍影响，我认为国王应该愿意出这笔钱）。在拜占庭时期，因为没有网络，构造上述这样的系统，是完全不可能的。而现在网络链路速度，效率越来越高，让区块链解决一致性问题得以解决

这里就引出了现在区块链的核心问题：应用场景与代价博弈。你要解决的痛点，到底值不值得这样的花费呢？无论是算力消耗，还是资源消耗，亦或是类似于上述案例中的国王出资（区块链代币价值为负数？），都是一种【代价】。完全的信任是不存在的，只有当造假（走捷径获得利润）的成本远远高于得到的利润，才能取得信任（一致性）

### 区块共识

一旦有人提议区块，我们如何达成共识？

#### 中本聪共识

- 用于比特币和大多数PoW系统中

- 它有一条单一规则：“当你看到提议的区块拥有最多工作量证明，就接受它。“

- 通常来说，具有最高编号的区块拥有最多的工作量证明

- <font color='blue'>中本聪共识的特点是，最终的共识产生在最长链上，所以如果有攻击者侥幸获得了某一次的出块权，那么对网络的安全是没有影响的，因为最长链是一个多轮博弈的结果。POW 机制保障了只要攻击者没有持有超过50%的算力，那么他就不可能通过一己之力生成最长链。 </font>（我的理解是，攻击者若获得出块权，想攻击的话，要么在最长链上提供一个假的区块，但是这样的话，很快就能被区块链识破，因为跟前面的区块对不上；要么就是产生一条全新的最长链，但是这要求巨大的算力和资金，所以很难）

- 比特币的最长链规则，确认的区块深度越长，交易越难被逆转：

  例如，在区块编号100接受了区块A，之后在区块编号103接收到区块B，但是发现在编号100处有和之前不同的区块，根据最长链规则，要反转之前收到的区块A，转而接受新的这一块。

> 拜占庭将军问题：
>
> 如果有一组人想通过投票就一个事情达成共识，但是大家无法集中到一起，只能相互联系。 那么显然，如果这个过程中有太多人乱投票，共识就达不成了。  根据数学推导，得出的数据是只要有三分之一的人捣乱，就不可能达成共识了，这就是拜占庭将军问题。 

#### 经典共识

- 实用拜占庭容错算法（PBFT）（Practical Byzantine Fault Tolerance）：

  让一组参与者进行多轮投票，直到一定比例的投票者达成共识。 一旦他们投票通过，区块就有了**最终性**。因此，就**不存在区块回滚**的事情。如果存在争议，那么系统会停止。 

[共识算法](https://www.cnblogs.com/X-knight/p/9157814.html)

#### 如何选择共识算法

- 构建的应用对最终性的急需程度：

  若构建的是去中心化的交易所，最终性很重要，要保证交易不可逆转；若只是用于微支付等新型支付系统，交易逆转倒不是很严重的问题

  >  作为参考，比特币的最终性大约是1小时左右（蓝狐笔记注：比特币6个区块确认完成，基本上可以确认交易完成，但这也不是100%的最终性，不过在6个区块确认之后，要逆转交易的难度非常之大。）以太坊的最终性大约6分钟左右，而Tendermint Core有1秒的最终性。 

  

- 构建的应用所需的快速程度：

   如果你构建的是游戏应用，每个动作前需要等待15秒钟（甚至更长时间）是否合理？ 

- 构建的应用所需的去中心化程度：

   有的应用，比如自治银行，它对去中心化要求很高。 

   一些应用，比如游戏，可能并不需要显著的抗审查特性，这只是去中心化的副产品。 

#### 共识算法与CAP理论：

CAP是由Eric Brewer在2000年PODC会议上，提出分布式系统不能同时完全满足三个要求的假设,其中包括 ：

- Consistency： 

  一致性，是指在分布式系统中的所有数据备份 , 在同一时刻是否具有同样的值。

- Avaliability： 

  可用性，是指在集群中一部分节点故障后，集群群体是否还能响应客户端的读写请求。

- Partition tolerance： 

  分区容错性，以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。

和所有的分布式系统一样，区块链共识算法设计也是在权衡上面的三个因素。 假设区块链中的节点能够立即确认交易数据，这就满足了CAP理论中的AP,可⻛险是失去了数据的强一致性，因为其他节点可能丢弃这个区块； 如果是为了获得强一致性，即满足CP的话，那么客户端应该等待区块链中的大多数节点都接受了这笔交易后才能真正的接收它，这说明了这笔交易所在的分叉已经选举胜利，获得了大部分的共识，获得了强一致性。但是代价却是失去了可用性。 

那么为什么没有CA这种情况呢?首先在分布式环境下，网络分区是一个自然的事实。因为分区是必然的，所以如果舍弃P，意味着要舍弃分布式系统，那这也就没有必要再讨论CAP理论了。 

#### 51%算力-共识攻击
如果同时接受到两条不同的区块链怎么办？
**只保留最长的且难度系数最高的，也就是包含的工作量最大的那一条**
而所谓51%算力的攻击，就是利用比特币网络采用PoW竞争记账权和“最长链共识”的特点，使用算力优势生成一条更长的链“回滚”已经发生的“交易行为”（产生假链去去更改现在的交易），你必须投入自己所有的工作量，不断给篡改后的区块链分叉增添新的区块。
在理论上，如果掌握了50%以上的算力，就拥有了获得记账权的绝对优势，可以更快地生成区块，也拥有了篡改区块链数据的权利。

因为贪婪（希望去竞争建立区块的建立和交易费）所以信任（全网算力越大，用户越放心）
假设Alice希望篡改一个交易信息，那么就意味着Alice需要不断的通过计算维护这个区块链了。也就是说每一次有新的区块链产生，Alice都需要不断的抢到这个彩票，理论上来说，他至少必须拥有全网51%以上的算力才能做到这一点，更多的，随着用户等待区块的增加，这个难度，幂次上升，在7-8个区块链产生后，概率上来讲，就是绝对信任
## 区块链技术演进

### 区块链1.0

1. 以区块为单位的链状数据块结构：

   区块链系统各节点通过一定的共识机制选取具有打包交易权限的区块节点，该节点需要将新区块的前一个区块的哈希值、当前时间戳、一段时间内发生的有效交易及其梅克尔树根值等内容打包成一个区块，向全网广播

2. 全网共享账本：

   在典型的区块链网络中，每一个节点都能够存储全网发生的历史交易记录的完整、一致账本，即对个别节点的账本数据的篡改、攻击不会影响全网总账的安全性。

3. 非对称加密：

   典型的区块链网络中，账户体系由非对称加密算法下的公钥和私钥组成，若没有私钥则无法使用对应公钥中的资产。

4. 源代码开源：

   区块链网络中设定的共识机制、规则等都可以通过一致的、开源的源代码进行验证。

![1640229186171](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1640229186171.png)

### 区块链2.0

1. 智能合约：

   区块链系统中的应用，是已编码的、可自动运行的业务逻辑，通常有自己的代币和专用开发语言。

2. DAPP：

   Decentralized Application，包含用户界面的应用，包括但不限于各种加密货币，如以太坊钱包。

3. 虚拟机：

   用于执行智能合约编译后的代码，虚拟机是图灵完备的。

![1640229596574](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1640229596574.png)

#### 以太坊（Ethereum）

简单来说，**以太坊就是区块链技术+智能合约**，是一个建立在区块链技术上的去中心化应用平台，它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。可能这里大家有些模糊，不妨这样的理解：以太坊就是区块链里的Android，他就是一个开发平台，让我们就可以像给予Android Framework一样基于区块链技术写应用。

没有以太坊之前，写区块链应用是这样的：拷贝一份比特币代码，然后去改底层代码如加密算法，共识机制，网络协议等等。

可编程、可视化、更易用的区块链，允许任何人编写智能合约和发行代币，他提供了一套图灵完备的脚本语言，因此开发人员可以直接用c语言等高级语言编程，转换成汇编语言，大大降低了区块链应用的开发难度，就好比安卓系统，提供了非常丰富的API和接口，让用户可开发出更多app。

**智能合约又是什么？**

以太坊上的程序称之为智能合约，它是代码和数据（状态）的集合。智能合约可以理解为在区块链上可以自动执行的（由事件驱动的）、以代码形式编写的合同（特殊的交易）。

智能合约非常适合对信任、安全和持久性要求较高的应用场景，比如：数字货币、数字资产、投票、保险、金融应用、预测市场、产权所有权管理、物联网、点对点交易等等。 

>  关于智能合约，在以太坊白皮书中，维塔利克用的词汇是“实现预先设定规则的一段代码”（implementing arbitrary rules）。在区块链上，这些代码的用途是控制链上的数字资产的转移。 

> DeFi（去中心化金融）：
>
> DeFi是一个去中心化应用（Decentralized Applications，Dapps）的生态系统，其提供建立在分布式网络之上**无治理机构**的金融服务。目前，大部分的DeFi应用皆建立在以太坊区块链之上。
>
> 稳定币，类似于当铺给你现金

> NFT（非同质化代币）：
>
> Non-Fungible Token，即非同质化代币，具有不可分割、不可替代、独一无二等特点。相当于带有编号的人民币，这个世界上不会有两张编号一样的人民币，也不会有两个完全一样的NFT。
>
> NFT的关键创新之处在于提供了一种标记原生数字资产所有权的方法

### 区块链3.0

目前还处于区块链2.0上升阶段

### 区块链未来

- 区块链电商
- 区块链网约车
- 区块链教育

## 区块链分类

1. 根据网络范围分类：

|          |                        公有链                        |                            联盟链                            |                            私有链                            |
| :------: | :--------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   身份   |              匿名或化名为主，节点不可信              |                 需要验证，或许存在不可信节点                 |                        授权，节点可信                        |
| 交易内容 |              可见、可读取、任何人可参与              |   授权公开、允许每个人读取、或者只受限于参与者、或混合路线   | 写入权限仅控制在一个组织手里的区块链。读取权限或对外开放，或者做了任意程度的限制。 |
| 共识机制 | 非授权，竞争性记账，工作量证明或者权益证明机制等方式 |            PBFT等共识过程受到预选节点控制的区块链            |                 共识过程由预先选好的节点控制                 |
| 网络架构 |                     完全去中心化                     |                      半开放、多去中心化                      |                     封闭网络、中心化架构                     |
| 龙头产品 |                    比特币、以太坊                    | 超级账本（像银行间进行支付、结算、清算的系统就能够采用联盟链的形式，将各家银行的网关节点作为记账节点） |                                                              |

ps：联盟链不一定要完全管控 

2. 根据部署环境：

- 主链
- 测试链

2. 根据对接类型：

- 单链：

   能够单独运行的区块链系统都可以成为是“单链”，比如比特币主链、测试链，以太坊主链与测试链 

- 侧链：

   侧链属于一种区块链系统的跨链技术。 区块链系统与侧链系统本身都是一个独立的链系统，两者之间可以按照一定的协议进行数据互动，通过这种方式，侧链能起到一个队主链功能扩展的作用，很多在主链中不方便实现的功能可以在侧链中实现，而侧链再通过与主链数据交互增强自己的可靠性 

- 互联链





## IDEAs

数字人民币与区块链

https://xw.qq.com/cmsid/20211216A09N0500